use crate::*;
use gstring::GStringTrait;
use icu_properties::props::{BidiClass, Dash};
use icu_properties::{CodePointMapData, CodePointSetData};
use itertools::Itertools;
use std::collections::BTreeMap;
use std::iter;
use std::sync::LazyLock;
use tuples::TupleIter;
use unicase::UniCase;
use unicode_matching::FindMatching;
use unicode_segmentation::UnicodeSegmentation;

#[derive(Debug)]
pub struct Guess {
    /// Artist and title. There's no guarantee as to which is which, but artist tends to be first
    pub components: (UniCase<String>, UniCase<String>),
    /// confidence score between 0 and 1.
    /// guesses generated by fallback matches have lower confidence, but might still be correct in many cases.
    pub confidence: f32,
}

impl Guess {
    fn new(
        components: (impl Into<UniCase<String>>, impl Into<UniCase<String>>),
        confidence: impl Into<f32>,
    ) -> Self {
        Self {
            components: (components.0.into(), components.1.into()),
            confidence: confidence.into(),
        }
    }

    fn cured_clone(&self) -> Result<Self> {
        let cure = |s: &UniCase<String>| decancer::cure!(s.as_str()).map(|c| c.to_string());

        let components = (cure(&self.components.0)?, cure(&self.components.1)?);
        Ok(Guess::new(components, self.confidence - 0.05))
    }
}

pub struct ParseOutput {
    /// Sorted by confidence (higher = first)
    pub guesses: Vec<Guess>,
}

impl From<Vec<Guess>> for ParseOutput {
    fn from(mut guesses: Vec<Guess>) -> Self {
        // reverse order
        guesses.sort_by(|a, b| b.confidence.total_cmp(&a.confidence));

        // Cull duplicates - since we sorted first, higher-confidence duplicates will remain
        let guesses = guesses
            .into_iter()
            .unique_by(|a| {
                a.components
                    .iter()
                    .cloned()
                    .sorted() // Hack - we could use a Set, but it's not Hash
                    .collect_vec()
            })
            .collect();

        Self { guesses }
    }
}

impl From<Guess> for ParseOutput {
    fn from(guess: Guess) -> Self {
        Self {
            guesses: vec![guess],
        }
    }
}

pub fn guess_search_query(
    channel: impl Into<String>,
    title: impl Into<String>,
    _duration: usize,
) -> ParseOutput {
    let mut guesses = vec![];
    let channel = UniCase::new(channel.into());
    let title = UniCase::new(title.into());

    let (c_trimmed, c_trim_confidence) = trim_channel_name(&channel);
    let title_trimmed = trim_title(&title);

    let try_splitting = [
        (&channel, &title, 0.2),
        (&c_trimmed, &title, 0.3),
        (&channel, &title_trimmed, 0.3),
        (&c_trimmed, &title_trimmed, 0.4),
    ];
    for (c, t, conf) in try_splitting {
        if let Some(guess) = guess_title_split(c, t, conf) {
            guesses.push(guess)
        }
    }

    guesses.push(Guess::new(
        (c_trimmed, title_trimmed),
        0.3 + c_trim_confidence,
    ));
    guesses.push(Guess::new((channel, title), 0.2));

    let cured = guesses
        .iter()
        .filter_map(|g| g.cured_clone().ok())
        .collect_vec();
    guesses.extend(cured);

    guesses.into()
}

fn guess_title_split(
    channel: &UniCase<String>,
    title: &UniCase<String>,
    confidence: f32,
) -> Option<Guess> {
    let split_positions = find_title_split(title);
    let single_split = split_positions.len() == 1;

    single_split.then(|| {
        let n = split_positions[0];
        let chars: Vec<_> = title.chars().collect();

        let (g1, g2) = chars.split_at(n);
        let g1 = UniCase::new(String::from_iter(g1).trim().to_string());
        let g2 = UniCase::new(String::from_iter(g2.split_at(1).1).trim().to_string());

        let mut confidence = confidence;
        if [&g1, &g2].contains(&channel) {
            confidence += 0.2;
        }
        Guess::new((g1, g2), confidence)
    })
}

fn find_title_split(t: &str) -> Vec<usize> {
    let chars = t.chars().collect_vec();
    let positions_for = |fun: fn(char) -> bool| {
        chars
            .iter()
            .enumerate()
            .filter(|(_, c)| fun(**c))
            .map(|p| p.0)
            // Remove first and last - we don't want to split on those
            .filter(|i| *i != 0 && *i != t.len() - 1)
            .collect()
    };
    let surrounded_by_whitespace = |pos| {
        chars
            .get(pos - 1)
            .map(|c: &char| c.is_whitespace())
            .unwrap_or_default()
            && chars
                .get(pos + 1)
                .map(|c: &char| c.is_whitespace())
                .unwrap_or_default()
    };

    let dashes: Vec<_> = positions_for(|c| CodePointSetData::new::<Dash>().contains(c));

    let mut dashes_surrounded = dashes.clone();
    dashes_surrounded.retain(|pos| surrounded_by_whitespace(*pos));

    if !dashes_surrounded.is_empty() {
        return dashes_surrounded;
    }
    if !dashes.is_empty() {
        return dashes;
    }

    let others = positions_for(|c| {
        CodePointMapData::<BidiClass>::new().get(c) == BidiClass::CommonSeparator
    });

    let mut others_surrounded = dashes.clone();
    others_surrounded.retain(|pos| surrounded_by_whitespace(*pos));

    if !others_surrounded.is_empty() {
        return others_surrounded;
    }
    others
}

fn trim_channel_name(c: &UniCase<String>) -> (UniCase<String>, f32) {
    let mut trimmed = c.trim_end_matches(" - Topic");
    if trimmed.len() != c.len() {
        return (trimmed.into(), 0.2);
    }

    trimmed = trimmed
        .trim_end_matches("VEVO")
        .trim_end_matches("Official");

    (trimmed.into(), 0.)
}

fn trim_title(t: &UniCase<String>) -> UniCase<String> {
    let (stripped, t_blocks) = extract_trailing_blocks(t);
    let (stripped, p_blocks) = extract_parenthesized_blocks(&stripped);
    let remaining_blocks = t_blocks
        .into_iter()
        .chain(p_blocks)
        .filter(|s| should_keep_block(s));

    iter::once(stripped)
        .chain(remaining_blocks)
        .map(remove_conjunction_words)
        .join(" ")
        .into()
}

fn extract_trailing_blocks(t: &UniCase<String>) -> (String, Vec<String>) {
    let common_separators = ["/", "|", "||"];
    let lower = t.to_lowercase();
    let mut stripped = lower.split_whitespace().collect_vec();

    let is_alphanumeric = |s: &&str| s.chars().all(char::is_alphanumeric);

    let mut find_last_block = || {
        let (idx, _) = stripped
            .iter()
            .enumerate()
            .rfind(|(_, s)| common_separators.contains(s))?;
        let (before, block) = stripped.split_at(idx);
        if idx > 0 && block.iter().skip(1).all(is_alphanumeric) {
            let block = block.split_at(1).1.join(" ");
            stripped = before.to_vec();
            return Some(block);
        }
        None
    };

    let mut blocks = vec![];
    while let Some(block) = find_last_block() {
        blocks.push(block)
    }
    (stripped.join(" "), blocks)
}

fn remove_conjunction_words(t: String) -> UniCase<String> {
    let lower = t.to_lowercase();
    let conjunctions = [
        "ft.", "feat.", "feat", "ft", "vs", "vs.", "x", "by", "fka", // formerly known as
        "aka",
    ];
    // unicode word bounds separate abbreviations from their full stop: "feat." -> ["feat", "."]
    // so we split by whitespace first
    let first_pass = lower
        .split_whitespace()
        .filter(|s| !conjunctions.contains(s))
        .join(" ");
    first_pass
        .split_word_bounds()
        .filter(|s| !conjunctions.contains(s))
        .join("")
        .into()
}

fn should_keep_block(block: &str) -> bool {
    let words = block
        .unicode_words()
        .map(|s| s.to_lowercase())
        .collect_vec();
    let words = words.iter().map(|s| s.as_str()).collect_vec();

    let Some(last_word) = words.last() else {
        return false;
    };
    let Some(first_word) = words.first() else {
        return false;
    };

    let last_word_whitelist = ["remix", "bootleg", "flip", "vip", "edit", "blend"];

    let remaster = first_word.starts_with("remaster") || last_word.starts_with("remaster");
    let cover = [first_word, last_word].contains(&&"cover");

    last_word_whitelist.contains(last_word) || cover || remaster
}

static ICU_MATCHING_OPEN: LazyLock<BTreeMap<&str, &str>> = LazyLock::new(unicode_matching::open);
static ICU_MATCHING_CLOSE: LazyLock<BTreeMap<&str, &str>> = LazyLock::new(unicode_matching::close);

fn extract_parenthesized_blocks(s: &str) -> (String, Vec<String>) {
    let mut stripped = s.gstring();

    let mut remove_last_block = || -> Option<String> {
        let graphemes = stripped.clone().into_graphemes();
        let mut graphemes = graphemes.iter().map(|g| g.as_str()).collect_vec();
        let (open, close) = graphemes.iter().enumerate().rev().find_map(|(pos, _)| {
            let open_pos = stripped.find_matching(pos, &ICU_MATCHING_CLOSE, &ICU_MATCHING_OPEN);
            (open_pos != pos).then_some((open_pos, pos))
        })?;

        let mut inside = graphemes.split_off(open + 1); // exclude opening bracket
        graphemes.pop(); // and drop it

        let mut outside = graphemes;
        outside.push(" "); //will get cleaned up later
        outside.extend(inside.split_off(close - open));

        inside.pop(); // drop included closing bracket
        stripped = String::from_iter(outside).gstring();
        Some(String::from_iter(inside).trim().to_string())
    };

    let mut blocks = vec![];
    while let Some(block) = remove_last_block() {
        blocks.push(block)
    }

    let stripped = stripped
        .to_string()
        .split_whitespace()
        .filter(|s| !s.is_empty())
        .join(" ");

    (stripped, blocks)
}

#[cfg(test)]
mod test {
    use crate::title_parse::{extract_parenthesized_blocks, guess_search_query, Guess};
    use comfy_table::*;
    use itertools::Itertools;
    use poise_error::anyhow::Result;
    use serde::Deserialize;
    use std::collections::HashSet;
    use tuples::TupleIter;
    use unicode_segmentation::UnicodeSegmentation;

    fn check_guess(guess: &Guess, control: &str) -> bool {
        let control = control.to_lowercase();
        let guess = format!("{} {}", guess.components.0, guess.components.1).to_lowercase();

        let control: HashSet<_> = control.unicode_words().collect();
        let query: HashSet<_> = guess.unicode_words().collect();

        let equal = control == query;
        let contains_most_real_words =
            query.is_subset(&control) && (query.len() as f32 / control.len() as f32) > 0.7;

        equal || contains_most_real_words
    }

    #[derive(Deserialize)]
    struct TestRecord {
        channel: String,
        title: String,
        control: String,
    }
    #[test]
    fn test() -> Result<()> {
        let index_file = include_bytes!("../title_parse_reference.csv").as_slice();
        let reader = csv::Reader::from_reader(index_file);

        let mut results: Vec<_> = reader
            .into_deserialize()
            .filter_map(|r| r.ok())
            .map(|r: TestRecord| {
                let out = guess_search_query(r.channel.clone(), r.title.clone(), 0);
                let ok = out
                    .guesses
                    .iter()
                    .take(3)
                    .any(|g| check_guess(g, &r.control));
                (ok, out, r)
            })
            .collect();

        results.sort_by_key(|x| x.0);

        let mut csv_writer = csv::Writer::from_path("title_parse_results.csv")?;
        let headers = ["OK", "channel", "title", "guesses", "confidence", "control"];

        let mut html = vec![
            csv2html::tablegen::start(true, "Test Results", ""),
            csv2html::tablegen::row(&headers, true, "", ""),
        ];
        csv_writer.write_record(headers)?;

        let mut table = Table::new();
        table.load_preset(presets::UTF8_FULL).set_header(headers);

        for (ok, out, r) in &results {
            let ok_str = ok.then_some('✓').unwrap_or('X').to_string();
            let channel = format!("{}\u{200E}", r.channel);
            let title = format!("{}\u{200E}", r.title);
            let mut guess_strs = out
                .guesses
                .iter()
                .take(3)
                .map(|g| g.components.iter().join(" ⸻	 "))
                .join("\u{200E}\n");
            guess_strs.push('\u{200E}');
            let confidences = out
                .guesses
                .iter()
                .take(3)
                .map(|g| g.confidence.to_string())
                .join("\n");
            let control = format!("{}\u{200E}", r.control);

            table.add_row(vec![
                Cell::new(&ok_str)
                    .fg(ok.then_some(Color::Green).unwrap_or(Color::Yellow))
                    .add_attribute(Attribute::Bold),
                Cell::new(&channel),
                Cell::new(title),
                Cell::new(&guess_strs),
                Cell::new(&confidences),
                Cell::new(&control),
            ]);
            csv_writer.write_record(vec![
                &ok_str,
                &r.channel,
                &r.title,
                &guess_strs,
                &confidences,
                &r.control,
            ])?;
            html.push(
                csv2html::tablegen::row(
                    &[
                        &ok_str,
                        &r.channel,
                        &r.title,
                        &guess_strs.replace("\n", "\\n"),
                        &confidences.replace("\n", "\\n"),
                        &r.control,
                    ],
                    false,
                    &format!("ok={ok_str}"),
                    "",
                )
                .replace("\\n", "<br>"),
            )
        }

        html.push(
            "<style>
            td:last-of-type {
                width: 20%;
            }
            table {
                font-family: Consolas, monospace;
                font-size: 0.8em;
                line-height: 1.4em;
                border-collapse: collapse;
            }
            td {
                border: 1px black solid;
                padding: 6px;
                padding-inline: 10px;
            }
            tr[ok~=\"✓\"] {
                color: lime;
            }
            tr[ok=\"X\"] {
                color: orange;
            }
            </style>
        "
            .into(),
        );
        html.push(csv2html::tablegen::end(true));
        std::fs::write("title_parse_results.html", html.join("\n"))?;
        std::fs::write("title_parse_results.txt", table.to_string())?;

        println!("{table}");

        assert!(results.iter().all(|(ok, _, _)| *ok));
        Ok(())
    }

    #[test]
    fn remove_brackets() {
        let s = "start (bracket 1) [bracket 2](bracket3 )middle{bracket4}end".to_string();
        let (outside, blocks) = dbg!(extract_parenthesized_blocks(&s));
        assert_eq!(outside, "start middle end");
        assert_eq!(
            blocks,
            vec!["bracket4", "bracket3", "bracket 2", "bracket 1"]
        );
    }
}
