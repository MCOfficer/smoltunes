use crate::*;
use gstring::GStringTrait;
use icu_properties::props::{BidiClass, Dash};
use icu_properties::{CodePointMapData, CodePointSetData};
use itertools::Itertools;
use tuples::TupleIter;
use unicase::UniCase;
use unicode_matching::FindMatching;

/// artist and title are commonly reversed
#[derive(Debug)]
pub struct Guess {
    /// Artist and title. There's no guarantee as to which is which, but artist tends to be first
    pub components: (UniCase<String>, UniCase<String>),
    /// confidence score between 0 and 1.
    /// guesses generated by fallback matches have lower confidence, but might still be correct in many cases.
    pub confidence: f32,
}

impl Guess {
    fn new(
        components: (impl Into<UniCase<String>>, impl Into<UniCase<String>>),
        confidence: impl Into<f32>,
    ) -> Self {
        Self {
            components: (components.0.into(), components.1.into()),
            confidence: confidence.into(),
        }
    }

    fn cured_clone(&self) -> Result<Self> {
        let cure = |s: &UniCase<String>| decancer::cure!(s.as_str()).map(|c| c.to_string());

        let components = (cure(&self.components.0)?, cure(&self.components.1)?);
        Ok(Guess::new(components, self.confidence - 0.05))
    }
}

pub struct ParseOutput {
    /// Sorted by confidence (higher = first)
    pub guesses: Vec<Guess>,
}

impl From<Vec<Guess>> for ParseOutput {
    fn from(mut guesses: Vec<Guess>) -> Self {
        // reverse order
        guesses.sort_by(|a, b| b.confidence.total_cmp(&a.confidence));

        // Cull duplicates - since we sorted first, higher-confidence duplicates will remain
        let guesses = guesses
            .into_iter()
            .unique_by(|a| {
                a.components
                    .iter()
                    .cloned()
                    .sorted() // Hack - we could use a Set, but it's not Hash
                    .collect_vec()
            })
            .collect();

        Self { guesses }
    }
}

impl From<Guess> for ParseOutput {
    fn from(guess: Guess) -> Self {
        Self {
            guesses: vec![guess],
        }
    }
}

pub fn guess_query_from(channel: String, title: String, _duration: usize) -> ParseOutput {
    let mut guesses = vec![];
    let channel = UniCase::new(channel);
    let title = UniCase::new(title);

    let (c_trimmed, c_trim_confidence) = trim_channel_name(&channel);
    let title_trimmed = trim_title(title.clone());

    let try_splitting = [
        (&channel, &title, 0.2),
        (&c_trimmed, &title, 0.3),
        (&channel, &title_trimmed, 0.3),
        (&c_trimmed, &title_trimmed, 0.4),
    ];
    for (c, t, conf) in try_splitting {
        if let Some(guess) = guess_title_split(c, t, conf) {
            guesses.push(guess)
        }
    }

    guesses.push(Guess::new(
        (c_trimmed, title_trimmed),
        0.3 + c_trim_confidence,
    ));
    guesses.push(Guess::new((channel, title), 0.2));

    let cured = guesses
        .iter()
        .filter_map(|g| g.cured_clone().ok())
        .collect_vec();
    guesses.extend(cured);

    guesses.into()
}

fn guess_title_split(
    channel: &UniCase<String>,
    title: &UniCase<String>,
    confidence: f32,
) -> Option<Guess> {
    let split_positions = find_title_split(title);
    let single_split = split_positions.len() == 1;

    single_split.then(|| {
        let n = split_positions[0];
        let chars: Vec<_> = title.chars().collect();

        let (g1, g2) = chars.split_at(n);
        let g1 = UniCase::new(String::from_iter(g1).trim().to_string());
        let g2 = UniCase::new(String::from_iter(g2.split_at(1).1).trim().to_string());

        let mut confidence = confidence;
        if [&g1, &g2].contains(&channel) {
            confidence += 0.2;
        }
        Guess::new((g1, g2), confidence)
    })
}

fn find_title_split(t: &str) -> Vec<usize> {
    let positions_for = |fun: fn(char) -> bool| {
        t.chars()
            .enumerate()
            .filter(|(_, c)| fun(*c))
            .map(|p| p.0)
            // Remove first and last - we don't want to split on those
            .filter(|i| *i != 0 && *i != t.len() - 1)
            .collect()
    };

    let dash_positions: Vec<_> = positions_for(|c| CodePointSetData::new::<Dash>().contains(c));
    if !dash_positions.is_empty() {
        return dash_positions;
    }

    positions_for(|c| CodePointMapData::<BidiClass>::new().get(c) == BidiClass::CommonSeparator)
}

fn trim_channel_name(c: &UniCase<String>) -> (UniCase<String>, f32) {
    let mut trimmed = c.trim_end_matches(" - Topic");
    if trimmed.len() != c.len() {
        return (trimmed.into(), 0.2);
    }

    trimmed = trimmed
        .trim_end_matches("VEVO")
        .trim_end_matches("Official");

    (trimmed.into(), 0.)
}

fn trim_title(t: UniCase<String>) -> UniCase<String> {
    trim_trailing_brackets(t)
}

fn trim_trailing_brackets(s: UniCase<String>) -> UniCase<String> {
    let close = unicode_matching::close();
    let open = unicode_matching::open();

    let gs = s.gstring();
    let last_pos = gs.graphemes().len() - 1;
    let opening_pos = gs.find_matching(last_pos, &close, &open);

    if last_pos != opening_pos {
        let trimmed_graphemes: Vec<_> = gs.graphemes().iter().take(opening_pos).cloned().collect();
        return trimmed_graphemes.join("").trim_end().to_owned().into();
    }
    s
}

#[cfg(test)]
mod test {
    use crate::title_parse::{guess_query_from, Guess};
    use comfy_table::*;
    use itertools::Itertools;
    use poise_error::anyhow::Result;
    use serde::Deserialize;
    use std::collections::HashSet;
    use tuples::TupleIter;
    use unicode_segmentation::UnicodeSegmentation;

    fn check_guess(guess: &Guess, control: &str) -> bool {
        let control = control.to_lowercase();
        let guess = format!("{} {}", guess.components.0, guess.components.1).to_lowercase();

        let control: HashSet<_> = control.unicode_words().collect();
        let query: HashSet<_> = guess.unicode_words().collect();

        let equal = control == query;
        let contains_most_real_words =
            query.is_subset(&control) && (query.len() as f32 / control.len() as f32) > 0.75;

        equal || contains_most_real_words
    }

    #[derive(Deserialize)]
    struct TestRecord {
        channel: String,
        title: String,
        control: String,
    }
    #[test]
    fn test() -> Result<()> {
        let index_file = include_bytes!("../title_parse_reference.csv").as_slice();
        let reader = csv::Reader::from_reader(index_file);

        let mut results: Vec<_> = reader
            .into_deserialize()
            .filter_map(|r| r.ok())
            .map(|r: TestRecord| {
                let out = guess_query_from(r.channel.clone(), r.title.clone(), 0);
                let ok = out
                    .guesses
                    .iter()
                    .take(3)
                    .any(|g| check_guess(g, &r.control));
                (ok, out, r)
            })
            .collect();

        results.sort_by_key(|x| x.0);

        let mut csv_writer = csv::Writer::from_path("title_parse_results.csv")?;
        let headers = ["OK", "channel", "title", "guesses", "confidence", "control"];

        let mut html = vec![
            csv2html::tablegen::start(true, "Test Results", ""),
            csv2html::tablegen::row(&headers, true, "", ""),
        ];
        csv_writer.write_record(headers)?;

        let mut table = Table::new();
        table.load_preset(presets::UTF8_FULL).set_header(headers);

        for (ok, out, r) in &results {
            let ok_str = ok.then_some('✓').unwrap_or('X').to_string();
            let channel = format!("{}\u{200E}", r.channel);
            let title = format!("{}\u{200E}", r.title);
            let mut guess_strs = out
                .guesses
                .iter()
                .take(3)
                .map(|g| g.components.iter().join(" ||| "))
                .join("\u{200E}\n");
            guess_strs.push('\u{200E}');
            let confidences = out
                .guesses
                .iter()
                .take(3)
                .map(|g| g.confidence.to_string())
                .join("\n");
            let control = format!("{}\u{200E}", r.control);

            table.add_row(vec![
                Cell::new(&ok_str)
                    .fg(ok.then_some(Color::Green).unwrap_or(Color::Yellow))
                    .add_attribute(Attribute::Bold),
                Cell::new(&channel),
                Cell::new(title),
                Cell::new(&guess_strs),
                Cell::new(&confidences),
                Cell::new(&control),
            ]);
            csv_writer.write_record(vec![
                &ok_str,
                &r.channel,
                &r.title,
                &guess_strs,
                &confidences,
                &r.control,
            ])?;
            html.push(
                csv2html::tablegen::row(
                    &[
                        &ok_str,
                        &r.channel,
                        &r.title,
                        &guess_strs.replace("\n", "\\n"),
                        &confidences.replace("\n", "\\n"),
                        &r.control,
                    ],
                    false,
                    &format!("ok={ok_str}"),
                    "",
                )
                .replace("\\n", "<br>"),
            )
        }

        html.push(
            "<style>
            td:last-of-type {
                width: 20%;
            }
            table {
                font-family: Consolas, monospace;
                font-size: 0.8em;
                line-height: 1.4em;
                border-collapse: collapse;
            }
            td {
                border: 1px black solid;
                padding: 6px;
                padding-inline: 10px;
            }
            tr[ok~=\"✓\"] {
                color: lime;
            }
            tr[ok=\"X\"] {
                color: orange;
            }
            </style>
        "
            .into(),
        );
        html.push(csv2html::tablegen::end(true));
        std::fs::write("title_parse_results.html", html.join("\n"))?;
        std::fs::write("title_parse_results.txt", table.to_string())?;

        println!("{table}");

        assert!(results.iter().all(|(ok, _, _)| *ok));
        Ok(())
    }
}
